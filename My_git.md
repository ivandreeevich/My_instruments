# Что такое система контроля версий

Система контроля версий представляет собой программное обеспечение, которое позволяет отслеживать изменения в документах, при необходимости производить их откат, определять, кто и когда внес исправления. 
Историю их проектов хранит отдельная программа — система контроля версий (англ. **Version Control System**, или коротко **VCS**).
Одно изменение или группу изменений в VCS называют ревизией или версией. Каждая такая ревизия содержит информацию о том, что изменилось, кто внёс изменения, когда это было и иногда комментарии к изменению.
	
#### Основные функции системы контроля версий:
*	хранит историю изменений в виде отдельных ревизий;
*	позволяет манипулировать историей: например, менять порядок ревизий, полностью удалять версии, возвращаться назад в истории;
*	помогает анализировать изменения: например, кто и когда вносит изменения, кто чаще всего вносит изменения в определённый файл и так далее.

Одна из ключевых особенностей современных систем контроля версий — поддержка параллельной работы нескольких пользователей, в том числе над одним файлом. Именно поэтому VCS так популярны у IT-команд.

## Локальные системы 

Для того чтобы контролировать версии, многие люди копируют файлы в другую папку. Возможно даже, если они достаточно сообразительны, копируют в другую папку с отметкой времени. Такой способ распространён из-за своей простоты, однако он невероятно ненадёжен. Можно легко забыть, в какой папке вы находитесь, и случайно записать не в тот файл или скопировать не те файлы, которые вы хотели.
        

## Централизованная система 

Следующая серьёзная проблема, с которой сталкиваются люди, это необходимость взаимодействовать с другими разработчиками. Для её решения были придуманы централизованные системы контроля версий. Они имеют один сервер, содержащий все версии файлов, и некоторое количество клиентов, которые извлекают файлы из этого центрального хранилища. Применение централизованных систем контроля версий являлось стандартом на протяжении многих лет.

Такой подход имеет множество преимуществ, особенно перед локальными системами контроля версий. Например, все разработчики проекта более или менее знают, чем занимается каждый из них. Администраторы имеют полный контроль над тем, кто и что может делать, и им гораздо проще администрировать централизованную систему контроля версий, чем оперировать локальными базами данных на каждом клиенте.

Однако данный подход имеет и серьёзные минусы. Самый очевидный минус - это единая точка отказа, которой является центральный сервер. Если этот сервер выйдет из строя на час, то в течение этого времени никто вообще не сможет ни взаимодействовать друг с другом, ни сохранить изменения в файле, с которым он работает. Если жёсткий диск, где хранится центральная база данных, окажется повреждён, а резервных копий не будет, то вы потеряете всю историю проекта, за исключением единичных снимков репозитория, которые сохранились на локальных машинах разработчиков. Кстати, локальные системы контроля версий страдают от той же самой проблемы: поскольку вся история проекта хранится в одном месте, вы рискуете потерять всё.
        
       
## Децентрализованные системы 

Здесь в игру вступают децентрализованные системы контроля версий. Это такие системы, как Git, Mercurial, Bazaar или, например, Darcs. В них клиенты не просто извлекают последний снимок всех файлов (состояние файлов на определённый момент времени) - они полностью копируют репозиторий, включая всю его историю. Такая операция называется клонированием. В этом случае, если какой-нибудь сервер, с которым взаимодействуют разработчики, выйдет из строя, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы. Каждый клон (копия) репозитория является полной резервной копией всех данных.
Более того, многие децентрализованные системы контроля версий могут одновременно взаимодействовать с несколькими удалёнными репозиториями. Благодаря этому вы можете взаимодействовать с различными группами людей, применяя различные подходы единовременно, в рамках одного проекта. Это позволяет вам использовать разные способы организации рабочего процесса, например, иерархические, которые невозможны в централизованных системах контроля версий.
        
       

## Что такое Git

**Git**  - 	система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит).    
**Важно!**	добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индек (``git add``), потом «сохраняем» (``git commit``).

![](https://pictures.s3.yandex.net/resources/S1_02_03_1684925317.png)
**Git** - это распределенная система управления версиями, разработанная Линусом Торвальдсом. Эта технология позволяет разработчикам сохранять все версии своего проекта и легко возвращаться к предыдущим состояниям. Особенно важным аспектом Git является возможность создания веток, что значительно облегчает совместную работу над проектами. Аналогами Git являются такие системы управления версиями, как Subversion, Perforce, Bazaar, которые также предоставляют средства для контроля за изменениями в проектах. Однако Git выделяется своей популярностью и масштабностью, широко используется в разнообразных областях разработки, и для работы с ним существует множество платформ, включая GitHub, GitLab, Bitbucket. Git позволяет разработчикам с легкостью сотрудничать, а также применяется не только для кода, но и для работы с различными типами файлов.

Ниже располагаются основные концепции и компоненты Git, которые необходимо понимать:
- **Репозиторий (Repository)** - это хранилище всех файлов, истории изменений и метаданных проекта. Он содержит все коммиты, ветки, теги и конфигурационные файлы. Репозиторий может быть локальным или удаленным;
- **Коммит (Commit)** - сохраненное состояние проекта в определенный момент времени. Коммит содержит информацию о внесенных изменениях, авторе, дате и сообщении коммита. Коммиты являются основными строительными блоками в истории проекта и образуют дерево коммитов. В качестве общепринятого стиля коммитов можно использовать [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/);
- **Ветка (Branch)** - это легковесная подвижная ссылка на коммит. Ветки позволяют разработчикам работать над разными фичами или исправлениями ошибок параллельно, не затрагивая основную линию разработки. Каждая ветка имеет свою собственную историю коммитов;
- **Ветвление (Branching)** - это создание новой ветки на основе существующей. Это позволяет разработчикам работать над различными фичами или задачами независимо друг от друга. Каждая ветка имеет свою собственную историю коммитов и изменения в одной ветке не влияют на другие ветки.
- **Слияние (Merge)** позволяет объединить изменения из одной ветки с другой. При слиянии Git автоматически интегрирует изменения из двух разных веток, результирующий коммит объединяет изменения обеих веток;
- **Удаленный репозиторий (Remote Repository)** - это репозиторий, расположенный на удаленном сервере или в облачном хранилище. Он предоставляет доступ к репозиторию другим разработчикам для совместной работы над проектом. Удаленный репозиторий позволяет разработчикам обмениваться коммитами и синхронизировать изменения;
- **Клонирование (Clone)** - создание локальной копии удаленного репозитория. Клонирование позволяет разработчику получить полную копию истории, файлов и веток проекта, которую можно изменять и коммитить локально;
- **Форк (Fork)** - это копия удаленного репозитория, созданная разработчиком с целью внести собственные изменения в проект. Форк позволяет работать над проектом независимо от исходного репозитория;
- **Запрос на слияние (Pull Request)** - это концепция, специфичная для систем управления версиями, таких как GitHub и GitLab. Представляет собой запрос от разработчика на слияние изменений из одной ветки в другую, часто из форка в исходный проект. После создания PR другие разработчики могут просмотреть, обсудить и, при необходимости, внести комментарии или изменения в предложенные изменения перед их слиянием;
- **Индекс (Index)** - это промежуточное хранилище, где разработчик помещает измененные файлы перед коммитом. Файлы, добавленные в индекс, готовы к коммиту и будут включены в следующий коммит;
- **Тег (Tag)** - это ссылка на конкретный коммит, используемая для пометки определенных состояний проекта, таких как релизы или важные моменты в истории проекта. Теги обычно используются для обозначения стабильных версий приложения;
- **HEAD** - это символическая ссылка на текущий коммит в вашем рабочем каталоге. Он указывает на коммит, с которым вы в данный момент работаете. Когда вы создаете новый коммит, HEAD обновляется, чтобы указывать на этот новый коммит;
- **Хеш (Hash)** или хеш-сумма - это уникальный идентификатор, который присваивается каждому коммиту, вычисляется на основе содержимого коммита, уникально идентифицирует этот коммит в истории проекта. Хеши используются для ссылки на коммиты и обеспечивают целостность данных.

## Основные команды Git

## Настройка Git

* **``git --version``**

**Установка имени и электронной почты.**

* **``git config --global user.name "Ваше имя"``**
* **``git config --global user.email "Ваша почта"``**

## Настройка Git

*	**Рабочая директория** — файловая система проекта (те файлы, с которыми вы работаете).
*	**Индекс** — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).
*	**Директория** — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).
*	У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.
*	Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Простейший цикл работ:
*	Редактирование, добавление, удаление файлов (собственно, работа).
*	Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
*	Коммит (фиксация изменений).
*	Возврат к шагу 1 или отход ко сну.

## Статусы файлов в Git

**Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.** 
        
**untracked (англ. «неотслеживаемый»)**

Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

**staged (англ. «подготовленный»)**

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда git add добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а git commit делает снимок всей сцены целиком


**tracked (англ. «отслеживаемый»)**

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.



**modified (англ. «изменённый»)**

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.
        
**Про staged и modified**

Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.

### Типичный жизненный цикл файла в Git
		
Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.
   
   ![](https://pictures.s3.yandex.net/resources/M2_T5_1686651284.png)
   
1.	Файл только что создали. Git про него ещё ничего не знает. Состояние: ``untracked``.
2.	Файл добавили в ``staging area`` с помощью ``git add``. Состояние: ``staged (+ tracked)``. 
*	Возможно, изменили файл ещё раз. Состояния: ``staged``, ``modified (+ tracked)``. Обратите внимание: ``staged`` и ``modified`` у одного файла, но у разных его версий.
*	Ещё раз выполнили ``git add``. Состояние: ``staged (+ tracked)``.
3.	Сделали коммит с помощью ``git commit``. Состояние: ``tracked``.
4.	Изменили файл. Состояние: ``modified (+ tracked)``.
5.	Снова добавили в ``staging area`` с помощью ``git add``. Состояния: ``staged (+ tracked)``.
6.	Сделали коммит. Состояния: ``tracked``.
7.	Повторили пункты 4−7 много-много раз.


**Важное:**

*	Статусом ``untracked`` помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность ``tracked``, в который попадают все файлы, отслеживаемые Git.
*	Файл переходит в статус ``staged`` после выполнения ``git add``.
*	Статус ``modified`` означает, что файл был изменён.
*	Большинство файлов в проектах «шагает» по следующему циклу: **«изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.**

## Шпаргалка. Базовые команды в консоли

### Навигация

* ``pwd`` (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;
* ``ls`` (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;
* ``ls -a`` — покажи также скрытые файлы и папки, названия которых начинаются с символа ``.``;
* ``cd first-projec`` (от англ. change directory, «сменить директорию») — перейди в папку ``first-project``;
* ``cd first-project/html`` — перейди в папку ``html``, которая находится в папке ``first-project``;
* ``cd ..`` — перейди на уровень выше, в родительскую папку;
* ``cd ~ ``— перейди в домашнюю директорию (``/Users/Username``);
* ``cd / ``— перейди в корневую директорию.


## Работа с файлами и папками

### Создание

*	``touch index.html`` (англ. touch, «коснуться») — создай файл ``index.html`` в текущей папке;
*	``touch index.html style.css script.js`` — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;
*	``mkdir second-project`` (от англ. **make directory**, «создать директорию») — создай папку с именем ``second-project`` в текущей папке.


### Копирование и перемещение

* ``cp file.txt ~/my-dir`` (от англ. copy, «копировать») — скопируй файл в другое место;
* ``mv file.txt ~/my-dir`` (от англ. move, «переместить») — перемести файл или папку в другое место.

### Чтение
* ``cat file.txt`` (от англ. concatenate and print, «объединить и распечатать») — распечатай содержимое текстового файла ``file.txt``.

### Удаление
* ``rm about.html`` (от англ. remove, «удалить») — удали файл ``about.html``;
* ``rmdir images`` (от англ. remove directory, «удалить директорию») — удали папку ``images``;
* ``rm -r second-project`` (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку ``second-project`` и всё, что она содержит.

### Полезные возможности

*	Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (``&&``).
*	У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (``↑``) и вниз (``↓``).
*	Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать ``Tab``.Если файл или папка есть в текущей директории, командная строка допишет путь сама.
*	Например, вы находитесь в папке ``dev``. Начните вводить ``cd first`` и дважды нажмите ``Tab``. Если папка ``first-project`` есть внутри ``dev``, командная строка автоматически подставит её имя. Останется только нажать ``Enter``.

## Шпаргалка. Начало работы с Git

 
### Инициализация репозитория

*	``git init`` (от англ. initialize, «инициализировать») — инициализируй репозиторий.

### Синхронизация локального и удалённого репозиториев

*	``git remote add origin https://github.com/YandexPracticum/first-project.git`` (от англ. remote, «удалённый» + add, «добавить») — привяжи локальный репозиторий к удалённому с URL ``https://github.com/YandexPracticum/first-project.git``;
*	``git remote -v``(от англ. verbose, «подробный») — проверь, что репозитории действительно связались;
*	``git push -u origin main`` (от англ. push, «толкать») — в первый раз загрузи все коммиты из локального репозитория в удалённый с названием ``origin``.
*	``git push`` (от англ. push, «толкать») — загрузи коммиты в удалённый репозиторий после того, как он был привязан с помощью флага ``-u``.


### Подготовка файла к коммиту

*	``git add todo.txt`` (от англ. add, «добавить») — подготовь файл ``todo.txt`` к коммиту;
*	``git add --all`` (от англ. add, «добавить» + all, «всё») — подготовь к коммиту сразу все файлы, в которых были изменения, и все новые файлы;
*	``git add .`` — подготовь к коммиту текущую папку и все файлы в ней.


### Создание и публикация коммита
*	``git commit -m "Комментарий к коммиту."``(от англ. commit, «совершать», фиксировать» + message, «сообщение») — сделай коммит и оставь комментарий, чтобы было проще понять, какие изменения сделаны;
* 	``git push`` (от англ. push, «толкать») — добавь изменения в удалённый репозиторий.


### Просмотр информации о коммитах

* ``git log`` (от англ. log, «журнал [записей]») — выведи подробную историю коммитов;
* ``git log --oneline`` (от англ. log, «журнал [записей]» + oneline, «одной строкой») — покажи краткую информацию о коммитах: сокращённый хеш и сообщение.

### Просмотр состояния файлов

*  ``git status`` (от англ. status, «статус», «состояние») — покажи текущее состояние репозитория.


### Добавление изменений в последний коммит

* ``git commit --amend --no-edit`` (от англ. amend, «исправить») — добавь изменения к последнему коммиту и оставь сообщение прежним;
* ``git commit --amend -m "Новое сообщение"`` — измени сообщение к последнему коммиту на ``Новое сообщение``.


### «Откат» файлов и коммитов

*	``git restore --staged hello.txt`` (от англ. restore, «восстановить») — переведи файл ``hello.txt`` из состояния ``staged`` обратно в ``untracked`` или ``modified``;
*	``git restore hello.txt`` — верни файл ``hello.txt`` к последней версии, которая была сохранена через ``git commit`` или ``git add``;
*	``git reset --hard b576d89`` (от англ. reset, «сброс», «обнуление» + hard, «суровый») — удали все незакоммиченные изменения из staging и «рабочей зоны» вплоть до указанного коммита.

### Просмотр изменений

*	``git diff`` (от англ. difference, «отличие», «разница») — покажи изменения в «рабочей зоне», то есть в ``modified``-файлах;
*	``git diff a9928ab 11bada1`` — выведи разницу между двумя коммитами;
*	``git diff --staged`` — покажи изменения, которые добавлены в ``staged``-файлах.

## Шпаргалка. Работа с ветками

    
### Клонирование чужого репозитория

*	``git clone git@github.com:YandexPraktikum/first-project.git`` (от англ. clone, «клон», «копия») — склонируй репозиторий с URL ``first-project.git`` из аккаунта ``YandexPraktikum`` на мой локальный компьютер.

### Создание веток

*	``git branch feature/the-finest-branch`` (от англ. branch, «ветка») — создай ветку от текущей с названием ``feature/the-finest-branch``;
*	``git checkout -b feature/the-finest-branch`` — создай ветку ``feature/the-finest-branch`` и сразу переключись на неё.

### Навигация по веткам

*	``git branch`` (от англ. branch, «ветка») — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);
*	``git branch -a`` — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в ``origin``, или на GitHub).
*	``git checkout feature/br`` — переключись на ветку ``feature/br``.

### Сравнение веток

*	``git diff main HEAD`` (от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на ``HEAD``;
*	``git diff HEAD~2 HEAD`` — покажи разницу между тем коммитом, который был два коммита назад, и текущим.

### Удаление веток

*	``git branch -d br-name`` — удали ветку ``br-name``, но только если она является частью main;
*	``git branch -D br-name`` — удали ветку ``br-name``, даже если она не объединена с main.


### Слияние веток

* ``git merge main`` (от англ. merge, «сливать», «поглощать») — объедини ветку ``main`` с текущей активной веткой. 


### Работа с удалённым репозиторием
*	``git push -u origin my-branch`` (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку ``my-branch`` в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто ``git push`` без ``-u``;
*	``git push my-branch`` — отправь дополнительные изменения в ветку ``my-branch``, которая уже существует в удалённом репозитории;
*	``git pull`` (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.


## Шпаргалка. Командная работа в Git

**Feature branch workflow**

Самый популярный подход к работе с Git в команде — это feature branch workflow. В нём создают ветку для каждой задачи (например, для новой функциональности или исправления бага), а когда всё готово, вливают новую ветку в main.
Важные этапы этого процесса — пул-реквест и ревью изменений. Пул-реквест — это интерфейс, в котором можно обсудить изменения. Ревью — просмотр изменений другими участниками и один из способов проверить качество таких изменений.
Если вы уже участник проекта (или collaborator в терминах GitHub), можно клонировать репозиторий напрямую. А если нет, нужно предварительно сделать «форк». Также для участников доступна кнопка Merge после ревью, а для неучастников — нет.

**Конфликты слияния**

Когда один и тот же файл меняется в нескольких ветках, при их слиянии может произойти конфликт. Пугаться конфликтов не нужно, это нормальная часть работы с системами контроля версий. IDE, вроде VSCode или Intellij IDEA, помогут «склеить» файл из двух конфликтующих версий.

### Алгоритм-шпаргалка для создания PR


1. Склонировать репозиторий. 
	+ Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.
	+ На странице репозитория или «форка» нажать кнопки: **Code → SSH → скопировать ссылку**.
	+ Выполнить команду ``git clone <ссылка на репозиторий>``.
2. Создать ветку для вашей задачи: ``git checkout -b my-task-branch-name``.
3. Добавить и «закоммитить» изменения, которые вы хотите внести в проект.
4.  «Запушить» ветку: ``git push --set-upstream origin HEAD`` или ``git push -u origin my-task-branch-name``.
	 + GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.
	 + PR можно также создать через интерфейс GitHub.
5. Сообщить о пул-реквесте ревьюеру.
	+ Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.
6. Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).
    + Если кто-то добавил конфликтующие изменения в ``main``, пока ваш PR был на ревью, нужно разрешить конфликт:  
+ Обновить ``main``: ``git checkout main && git pull``.
+ Влить ``main`` в свою ветку: ``git checkout my-task-branch-name && git merge main``.
+ Разрешить конфликты слияния с помощью IDE или вручную.
+ Создать коммит слияния: ``git commit --no-edit`` или ``git commit -m`` ``'merge main'``.
+ Сделать ``git push`` своей ветки.
7. Нажать кнопку **Merge** или подождать, пока её нажмёт кто-то ещё.
8. Ещё раз обновить "main", чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: ``"git checkout main && git pull"``.
9. Вы великолепны! Можете начинать снова со второго пункта.




### Указатели

- `HEAD` — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.
- `ORIG_HEAD` — указатель на коммит, с которого вы только что переместили `HEAD` (командой `git reset ...`, например).
- Ветка (`master`, `develop` etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.
- Теги — простые указатели на коммиты. Не перемещаются.

### Настройки

Перед началом работы нужно выполнить некоторые настройки:
*	``git config --global user.name "Your Name"`` указать имя, которым будут подписаны коммиты
*	``git config --global user.email "email@w.com"``  указать электропочту, которая будет в описании коммитера


### Создать новый репозиторий

* ``git init`` создать новый проект в текущей директории
* ``git init folder-name`` создать новый проект в указанной директории


### Клонирование репозитория

* ``git clone https://github.com/cyberspacedk/Git-commands.git`` клонировать удаленный репозиторий в одноименную директорию  
* ``git clone https://github.com/cyberspacedk/Git-commands.git FolderName`` клонировать удаленный репозиторий в директорию ``«FolderName»``
* ``git clone https://github.com:nicothin/web-design.git`` клонировать репозиторий в текущую директорию  


### Просмотр изменений

* ``git status`` показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)
* ``git diff`` сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ).
* ``git diff --color-word``s сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ).
* ``git diff index.html`` сравнить файл из рабочей директории и индекс.
* ``git diff HEAD`` сравнить рабочую директорию и коммит, на который указывает ``HEAD`` (неотслеживаемые файлы ИГНОРИРУЮТСЯ).
* ``git diff`` --staged сравнить индекс и коммит с ``HEAD``.
* ``git diff master feature`` посмотреть что сделано в ветке ``feature`` по сравнению с веткой ``master``.
* ``git diff --name-only master feature`` посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов.
* ``git diff master...feature`` посмотреть что сделано в ветке ``feature`` с момента (коммита) расхождения с ``master``.

### Добавление изменений в индекс

* ``git add .``        добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
* ``git add text.txt`` добавить в индекс указанный файл (был изменён, был удалён или это новый файл)
* ``git add -i``       запустить интерактивную оболочку для добавления в индекс только выбранных файлов
* ``git add -p ``      показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании


### Удаление изменений из индекса

*	``git reset``            убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод ``git add``
*	``git reset readme.txt`` убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)

## Отмена изменений

*	``git checkout text.txt``      ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе
*	``git reset --hard``           ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)
*	``git clean -df``              удалить неотслеживаемые файлы и директории

### Отмена коммитов и перемещение по истории

*	``git revert HEAD --no-edit``    создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения
*	``git revert b9533bb --no-edit`` то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)



**Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.**

#### ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения
* ``git commit --amend -m "Название"``  «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)
* ``git reset --hard @~``       передвинуть ``HEAD`` (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
* ``git reset --hard 75e2d51``  передвинуть ``HEAD`` (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита
* ``git reset --soft @~``       передвинуть ``HEAD`` (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения
* ``git reset --soft @~2``      то же, но передвинуть ``HEAD`` (и ветку) на 2 коммита назад
* ``git reset @~``              передвинуть ``HEAD`` (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем

#### Почти как ``git reset --hard``, но безопаснее: не получится потерять изменения в рабочей директории
* ``git reset --keep @~``       передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)

### Временно переключиться на другой коммит

* ``git checkout b9533bb`` - переключиться на коммит с указанным хешем (переместить ``HEAD`` на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)
* ``git checkout master``  - переключиться на коммит, на который указывает ``master`` (переместить ``HEAD`` на коммит, на который указывает ``master``, рабочую директорию вернуть к состоянию на момент этого коммита)

### Переключиться на другой коммит и продолжить работу с него

**Потребуется создание новой ветки, начинающейся с указанного коммита.**

* ``git checkout -b new-branch 5589877``   - создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить ``HEAD`` на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)



### Восстановление изменений

* ``git checkout 5589877 index.html`` - восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (``git reset index.html`` для удаления из индекса, но сохранения изменений в файле)

### Копирование коммита (перенос коммитов)

* ``git cherry-pick 5589877``          скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения
* ``git cherry-pick master~2..master`` скопировать на активную ветку изменения из ``master`` (2 последних коммита)
* ``git cherry-pick -n 5589877``      скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)
* ``git cherry-pick master..feature``   скопировать на активную ветку изменения из всех коммитов ветки ``feature`` с момента её расхождения с ``master`` (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт
* ``git cherry-pick --abort``    прервать конфликтный перенос коммитов
* ``git cherry-pick --continue`` продолжить конфликтный перенос коммитов (сработает только после решения конфликта)

### Удаление файла

* ``git rm text.txt``     удалить отслеживаемый неизменённый файл и проиндексировать это изменение
* ``git rm -f text.txt``  удалить отслеживаемый изменённый файл и проиндексировать это изменение
* ``git rm -r log/``     удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
* ``git rm ind*``         удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
* ``git rm --cached readme.txt``  удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)

### История коммитов

* ``git log master``              показать коммиты в указанной ветке
* ``git log -2 ``                показать последние 2 коммита в активной ветке
* ``git log -2 --stat``          показать последние 2 коммита и статистику внесенных ими изменений
* ``git log -p -22``              показать последние 22 коммита и внесенную ими разницу на уровне строк
* ``git log --graph -10``         показать последние 10 коммитов с ASCII-представлением ветвления
* ``git log --since=2.weeks``     показать коммиты за последние 2 недели
* ``git log --after '2018-06-30'``  показать коммиты, сделанные после указанной даты
* ``git log index.html``         показать историю изменений файла ``index.html`` (только коммиты)
* ``git log -5 index.html``      показать историю изменений файла ``index.html``, последние 5 коммитов (только коммиты)
* ``git log -p index.html``       показать историю изменений файла ``index.html`` (коммиты и изменения)
* ``git log -G'myFunction' -p``  показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)
* ``git log -L '/<head>/','/<\/head>/':index.html``  показать изменения от указанного до указанного регулярных выражений в указанном файле
* ``git log --grep fix``          показать коммиты, в описании которых есть буквосочетание ``fix`` (регистрозависимо, только коммиты текущей ветки)
* ``git log --grep fix -i``       показать коммиты, в описании которых есть буквосочетание ``fix`` (регистроНЕзависимо, только коммиты текущей ветки)
* ``git log --grep 'fix(ing|me)' -P``  показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)
* ``git log --pretty=format:"%h - %an, %ar : %s" -4``  показать последние 4 коммита с форматированием выводимых данных
* ``git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short``  мой формат вывода, висящий на алиасе оболочки
* ``git log master..branch_99``   показать коммиты из ветки ``branch_99``, которые не влиты в master
* ``git log branch_99..master``   показать коммиты из ветки ``master``, которые не влиты в branch_99
* ``git log master...branch_99 --boundary -- graph``  показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)
* ``git show 60d6582``            показать изменения из коммита с указанным хешем
* ``git show HEAD~``              показать данные о предыдущем коммите в активной ветке
* ``git show @~``                 аналогично предыдущему
* ``git show HEAD~3``             показать данные о коммите, который был 3 коммита назад
* ``git show my_branch~2``        показать данные о коммите, который был 2 коммита назад в указанной ветке
* ``git show @~:index.html``      показать контент указанного файла на момент предыдущего (от HEAD) коммита
* ``git show :/"подвал"``         показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)


### Кто написал строку


* ``git blame README.md --date=short -L 5,8``  показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены



### История изменений указателей (веток, HEAD)

* ``git reflog -20``             # показать последние 20 изменений положения указателя HEAD
* ``git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20`` # то же, но с указанием давности действий


### Ветки

* ``git branch``                  показать список веток
* ``git branch -v ``              показать список веток и последний коммит в каждой
* ``git branch new_branch``       создать новую ветку с указанным именем на текущем коммите
* ``git branch new_branch 5589877``  создать новую ветку с указанным именем на указанном коммите
* ``git branch -f master 5589877``   переместить ветку master на указанный коммит
* ``git branch -f master master~2``  переместить ветку master на 2 коммита назад
* ``git checkout new_branch``     перейти в указанную ветку
* ``git checkout -b new_branch``  создать новую ветку с указанным именем и перейти в неё
* ``git checkout -B master 5589877``  переместить ветку с указанным именем на указанный коммит и перейти в неё
* ``git merge hotfix``            влить в ветку, в которой находимся, данные из ветки hotfix
* ``git merge hotfix -m "Горячая правка"``  влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
* ``git merge hotfix --log``      влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
* ``git merge hotfix --no-ff``    влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
* ``git branch -d hotfix``        удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
* ``git branch --merged``         показать ветки, уже слитые с активной
* ``git branch --no-merged``      показать ветки, не слитые с активной
*  ``git branch -a``               показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
* ``git branch -m old_branch_name new_branch_name`` переименовать локально ветку ``old_branch_name`` в ``new_branch_name``
* ``git branch -m new_branch_name``  переименовать локально ТЕКУЩУЮ ветку в ``new_branch_name``
* ``git push origin :old_branch_name new_branch_name``  применить переименование в удаленном репозитории
* ``git branch --unset-upstream``  завершить процесс переименования


### Теги


* ``git tag v1.0.0``                создать тег с указанным именем на коммите, на который указывает ``HEAD``
* ``git tag -a -m 'В продакшен!' v1.0.1 master`` # создать тег с описанием на том коммите, на который смотрит ветка master
* ``git tag -d v1.0.0``             удалить тег с указанным именем(ами)
* ``git tag -n``                    показать все теги, и по 1 строке сообщения коммитов, на которые они указывают
* ``git tag -n -l 'v1.*'``          показать все теги, которые начинаются с 'v1.*'



### Временное сохранение изменений без коммита

* ``git stash``     временно сохранить незакоммиченные изменения и убрать их из рабочей директории
* ``git stash pop`` вернуть сохраненные командой git stash изменения в рабочую ``директорию``


### Удалённые репозитории

Есть два распространённых способа привязать удалённый репозиторий к локальному: по **HTTPS** и по **SSH**. Если SSH у вас не настроен (или вы не знаете что это), привязывайте удалённый репозиторий по HTTPS (адрес привязываемого репозитория должен начинаться с https://).


* ``git remote -v``              показать список удалённых репозиториев, связанных с локальным
* ``git branch -r``              показать удаленные ветки
* ``git branch -a``               показать все ветки(локальные и удаленные)       
* ``git remote remove origin``    убрать привязку удалённого репозитория с сокр. именем ``origin``
* ``git remote add origin https://github.com:nicothin/test.git`` # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
* ``git remote rm origin``        удалить привязку удалённого репозитория
* ``git remote show origin``      получить данные об удалённом репозитории с сокращенным именем ``origin``
* ``git fetch origin``            скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
* ``git fetch origin master``     то же, но скачивается только указанная ветка
* ``git checkout --track origin/github_branch`` # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем ``origin``, ветка ``github_branch``) и переключиться на неё
* ``git push origin master``      отправить в удалённый репозиторий (с сокр. именем ``origin``) данные своей ветки master 
* ``git pull origin``             влить изменения с удалённого репозитория (все ветки)
* ``git pull origin master``      влить изменения с удалённого репозитория (только указанная ветка)

### Конфликт слияния

Предполагается ситуация: есть ветка `master` и есть ветка `feature`. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку `master` пытаемся влить ветку `feature` (`git merge feature`), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле `index.html`.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.
 
* ``git merge feature``                 влить в активную ветку изменения из ветки feature
* ``git merge-base master feature``     показать хеш последнего общего коммита для двух указанных веток
* ``git checkout --ours index.html``    оставить в конфликтном файле ``(index.html)`` состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки ``master``)
* ``git checkout --theirs index.html``  оставить в конфликтном файле ``(index.html)`` состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки ``feature``)
* ``git checkout --merge index.html``   показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
* ``git checkout --conflict=diff3  --merge index.html``  показать в конфликтном файле ``(index.html)`` сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
* ``git reset --hard``   прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает ``HEAD``, а я пойду немного поплачу
* ``git reset --merge``  прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)



### «Перенос» ветки

Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

**Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий!!!**

* ``git rebase master``  перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от ``master`` на нынешней вершине master (часто вызывает конфликты)
* ``git rebase --onto master feature``  перенести коммиты активной ветки на ``master``, начиная с того места, в котором активная ветка отделилась от ветки ``feature``
* ``git rebase --abort``  прервать конфликтный ``rebase``, вернуть рабочую директорию и индекс к состоянию до начала ``rebase``
* ``git rebase --continue``  продолжить конфликтный ``rebase`` (сработает только после разрешения конфликта и индексации такого разрешения)

#### Как отменить rebase

* ``git reflog feature -2``        # смотрим лог перемещений ветки, которой делали ``rebase`` (в этом примере — ``feature``), видим последний коммит ПЕРЕД ``rebase``, на него и нужно перенести указатель ветки
* ``git reset --hard feature@{1}`` # переместить указатель ветки ``feature`` на один коммит назад, обновить рабочую директорию и индекс


## Примеры

Собираем коллекцию простых и сложных примеров работы.


## Начало работы

Создание нового репозитория, первый коммит, привязка удалённого репозитория с gthub.com, отправка изменений в удалённый репозиторий.

* ``git init``                       создаём репозиторий в этой директории
* ``touch readme.md``                создаем файл ``readme.md``
* ``git add readme.md``              добавляем файл в индекс
* ``git commit -m "Старт" ``         создаем коммит
* ``git remote add origin https://github.com:nicothin/test.git``  добавляем предварительно созданный пустой удаленный репозиторий
* ``git push -u origin master``      отправляем данные из локального репозитория в удаленный (в ветку ``master``)



### «Внесение изменений» в коммит

Только если коммит ещё не был отправлен в удалённые репозиторий.

**Указана последовательность действий:**

* ``git push -u origin master``      отправляем данные из локального репозитория в удаленный (в ветку ``master``)
* ``subl inc/header.html``           редактируем и сохраняем разметку «шапки»
* ``git add inc/header.html``        индексируем измененный файл
* ``git commit -m "Убрал телефон из шапки"`` # делаем коммит

**ВНИМАНИЕ: коммит пока не был отправлен в удалённый репозиторий**
			
**Создаём, что нужно было еще что-то сделать в этом коммите.**

* ``subl inc/header.html``           вносим изменения
* ``git add inc/header.html``        индексируем измененный файл (можно git add .)
* ``git commit --amend -m "«Шапка»: выполнена задача №34"``  заново делаем коммит


### Работа с ветками

Есть ``master`` (публичная версия сайта), выполняем масштабную задачу (переверстать «шапку»), но по ходу работ возникает необходимость подправить критичный баг (неправильно указан контакт в «подвале»).

**указана последовательность действий:**

* ``git checkout -b new-page-header``  создадим новую ветку для задачи изменения «шапки» и перейдём в неё
* ``subl inc/header.html``             редактируем разметку «шапки»
* ``git commit -a -m "Новая шапка: смена логотипа"`` # делаем коммит (работа еще не завершена)

**тут выясняется, что есть баг с контактом в «подвале»**

* ``git checkout master``              возвращаемся к ветке ``master``
* ``subl inc/footer.html``             устраняем баг и сохраняем разметку «подвала»
* ``git commit -a -m "Исправление контакта в подвале"``  делаем коммит
* ``git push``                         отправляем коммит с быстрым критическим изменением в master в удалённом репозитории
* ``git checkout new-page-header``     переключаемся обратно в ветку new-page-header для продолжения работ над «шапкой»
* ``subl inc/header.html``             редактируем и сохраняем разметку «шапки»
* ``git commit -a -m "Новая шапка: смена навигации"``  делаем коммит (работа над «шапкой» завершена)
* ``git checkout master``              переключаемся в ветку master
* ``git merge new-page-header``        вливаем в master изменения из ветки new-page-header
* ``git branch -d new-page-header``    удаляем ветку new_page_header

### Работа с ветками, слияние и откат к состоянию до слияния

Была ветка `fix`, в которой исправляли баг. Исправили, влили `fix` в `master`. но тут выяснилось, что это исправление ломает какую-то функциональность, Нужно откатить `master` к состоянию без слияния (наличие бага менее критично, чем порча функциональности).

**находимся в ветке fix, баг уже «исправлен»** 

* `git checkout master`             переключаемся на master
* `git merge fix`                   вливаем изменения из fix в master

**видим проблему: часть функциональности сломалась**
* `git checkout fix `              # переключаемся на fix (пока мы в master, `git` не даст ее двигать)
* `git branch -f master ORIG_HEAD` # передвигаем ветку `master` на коммит, указанный в `ORIG_HEAD` (тот, на который указывала master до вливания `fix`)

### Работа с ветками, конфликт слияния

Есть ветка `master` (публичная версия сайта), в двух параллельных ветках (`branch-1` и `branch-2`) было отредактировано одно и то же место одного и того же файла, первую ветку (`branch-1`) влили в master, попытка влить вторую вызывает конфликт.


**указана последовательность действий:**

* `git checkout master`            переключаемся на ветку `master`
* `git checkout -b branch-1`       создаём ветку `branch-1`, основанную на ветке `master`
* `subl .`                         редактируем и сохраняем файлы
* `git commit -a -m "Правка 1"`    коммитим
* `git checkout master`            возвращаемся к ветке `master`
* `git checkout -b branch-2`       создаём ветку `branch-2`, основанную на ветке master
* `git commit -a -m "Правка 2"`    коммитим
* `git checkout master`            возвращаемся к ветке `master`
* `git merge branch-1`             вливаем изменения из ветки `branch-1` в текущую ветку (`master`), удача (автослияние)
* `git merge branch-2`             вливаем изменения из ветки `branch-2` в текущую ветку (`master`), КОНФЛИКТ автослияния


### Синхронизация репозитория-форка с мастер-репозиторием

Есть некий репозиторий на **github.com**, он него нами был сделан форк, добавлены какие-то изменения. Оригинальный (мастер-)репозиторий был как-то обновлён. Задача: стянуть с мастер-репозитория изменения (которые там внесены уже после того, как мы его форкнули).

**указана последовательность действий:**

* `git remote add upstream https://github.com:address.git`  добавляем удаленный репозиторий: сокр. имя — `upstream`, `URL` мастер-репозитория
* `git fetch upstream`             стягиваем все ветки мастер-репозитория, но пока не сливаем со своими
* `git checkout master`            переключаемся на ветку ``master`` своего репозитория
* `git merge upstream/master`      вливаем стянутую ветку ``master`` удалённого репозитория `upstream` в свою ветку `master`



### Ошибка в работе: закоммитили в мастер, но поняли, что нужно было коммитить в новую ветку

**ВАЖНО: это сработает только если коммит еще не отправлен в удалённый репозиторий.**

**указана последовательность действий:**
**сделали изменения, проиндексировали их, закоммитили в master, но ЕЩЁ НЕ ОТПРАВИЛИ (не делали git push)**

* `git checkout -b new-branch`    создаём новую ветку из `master`
* `git checkout master`           переключаемся на `master`
* `git reset HEAD~ --hard`        сдвигаем указатель (ветку) `master` на 1 коммит назад
* `git checkout new-branch`       переключаемся обратно на новую ветку для продолжения работы


### Нужно вернуть содержимое файла к состоянию, бывшему в каком-либо коммите (известен хеш коммита)

**указана последовательность действий:**

*	``git checkout f26ed88 -- index.html`` # восстановить в рабочей директории состояние указанного файла на момент указанного коммита, добавить это изменение в индекс
*	``git commit -am "Navigation fixs"``   # сделать коммит


### Создание репозитория

`git init`: создание нового репозитория в текущей директории, в результате чего создается новая директория .git, где хранится вся информация о репозитории, коммитах, ветках и настройках
`git clone <URL>`: клонирование удаленного репозитория Git в локальную директорию - загружаются все коммиты, ветки и файлы из удаленного репозитория и создается локальная копия проекта

### Внесение изменений

`git status`: вывод измененных или новых файлов, которые в дальнейшем нужно проиндексировать
`git log`: вывод истории коммитов текущей ветки, содержащий хэш коммита, автора, время и сообщение коммита
`git log --oneline`: вариация команды `git log`, которая выводит более краткую историю коммитов, содержащую сокращенный хэш коммита и его сообщение в одной строке
`git diff`: разница между коммитами, ветками или файлами
`git add <file/dir>`: индексация файлы или директория для коммита
`git commit -m "<message name>"`: создание коммита с изменениями, добавленными в индекс

### Работа с ветками

`git branch`: список веток в репозитории
`git branch <branch>`: создание новой ветки
`git checkout <branch>`: переключение между ветками
`git checkout -`: загружает предыдущую ветку, удобно для быстрого переключения
`git stash`: используется для временного сохранения незавершенных изменений, чтобы переключиться на другую ветку или выполнить другие операции без потери работы
`git merge <branch>`: внесение изменения указанной ветки в текущую ветку
`git merge --no-ff <branch>`: внесение изменения указанной ветки в текущую ветку, так, что изменения из указанной ветки просто добавляются к основной ветке без создания дополнительного коммита слияния
`git branch -d <branch>`: удаление указанной ветки
`git rebase <branch>`: переписывание коммитов текущей ветки после коммитов в указанной ветке
`git fetch`: взятие всех изменений из удаленного репозитория и сохранение этих изменений локально
`git pull`: взятие всех изменений из удаленного репозитория и слиянние этих изменений с текущей веткой, работает как комбинация команд `git fetch` и `git merge`
`git push`: устанавливается становление связи с удалённым репозиторием, берутся все отсутствующие изменения удаленного репозитория и далее сохранение этих изменений в удаленный репозиторий

### Merge vs Rebase

Merge и Rebase - это два разных способа интеграции изменений из одной ветки в другую, которые стоит рассмотреть подробнее. Давайте разберемся с этими двумя командами и их особенностями:

#### Merge

Merge - это процесс объединения изменений из одной ветки в другую. При этом создается новый коммит, который объединяет изменения из обеих веток. Вот как выглядит процесс слияния:

1. Переключение на ветку, в которую хотим внести изменения `git checkout main`
2. Выполнение команды `git merge <branch>`, где <branch> - ветка, из которой вы хотите взять изменения.
3. Git попытается объединить изменения из указанной ветки в текущую. Если есть конфликты, Git попросит вас разрешить их вручную. Вы должны решить конфликты, сохранить изменения и сделать коммит, чтобы завершить слияние.

#### Rebase

Rebase - это более продвинутый способ интеграции изменений, который позволяет вам переписать историю коммитов текущей ветки так, как будто вы начали работу с этой веткой после изменений из другой ветки. Вот как это работает:

1. Переключение на ветку, в которую хотим внести изменения `git checkout main`
2. Выполнение команды `git rebase <branch>`, где <branch> - ветка, из которой вы хотите взять изменения.
3. Git возьмет ваши коммиты из текущей ветки и применит их поверх последнего коммита из указанной ветки. Если есть конфликты, вы должны их разрешить, как при слиянии.

Interactive Rebase позволяет контролировать, редактировать историю коммитов и многое другое.

Вы можете использовать команду `git rebase -i HEAD~N`, где N - это количество коммитов, которые вы хотите редактировать.

После запуска этой команды, вы увидите список коммитов в текстовом редакторе, где вы можете выбирать действия для каждого коммита (pick, squash, edit, et al.). Например, чтобы объединить коммиты в один, вы можете заменить pick на squash. После завершения интерактивного ребейза, вы можете использовать git push --force, чтобы отправить измененную историю в удаленный репозиторий.

# GitFlow

GitFlow является одной из наиболее популярных стратегий ветвления и слияния для управления версиями в Git. Он предоставляет структуру для эффективного сотрудничества между разработчиками, управления релизами и поддержкой долгосрочных и краткосрочных фич.

## Branching strategies

Cуществует множество различных стратегий ветвления, которые, разработчики выбирают в зависимости от потребностей и сложности своих проектов. В рамках этого документа рассмотрим стратегию GitFlow.

Основные ветки:
- **main**: стабильные и готовые к выпуску версии проекта, каждый коммит в этих ветках представляет собой новый релиз;
- **develop**: все новые функции и исправления ошибок сначала добавляются в эту ветку перед тем как они попадут в main.

Вспомогательные ветки:
- **feature**: создаются для разработки новых функций;
- **bugfix**: используются для исправления ошибок в коде;
- **hotfix**: используются для быстрого исправления критических ошибок, обнаруженных в релизе, вливается как в main, так и в develop;
- **release**: создаются для подготовки новых версий к релизу, завершается работа над версией, вносятся последние изменения и тестирование перед релизом.

## GitFlow use cases

Рассмотрим несколько end-to-end сценариев, связанных с работой над опенсорсными проектами, и проиллюстрируем их использование с помощью различных Git-команд. 

### Создание/клонирование репозитория

Разработчик хочет создать новый или же склонировать существующий репозиторий проекта.

При создании репозитория создается директория .git внутри директории проекта. Все данные Git, такие как история коммитов и настройки репозитория, хранятся в этой директории.

`git init`

При клонировании репозитория создается копия удаленного репозитория на локальной машине в новой директории с именем репозитория.

`git clone <URL>`

### Создание новой фичи

Разработчик хочет добавить новую фичу (функцию) в проект, для этого нужно создать и перейти в соответственную для этой фичи ветку.

`git checkout develop`

`git checkout feature/new-feature`


### Работа над фичей

Разработчик хочет внести изменения в код ветки фичи, для этого он должен коммитить изменения и пушить их в удаленный репозиторий.

`git add <files>` или `git add .` для добавления всех измененных файлов в индекс.

`git commit -m "feat: add [feature]"`

`git push origin feature/new-feature`


### Завершение работы над фичей и начало ревью

После завершения работы над фичей, разработчик создает Pull Request для интеграции своих изменений в основную ветку.

`git checkout develop`

`git pull origin develop`

Подтягивание последних изменений из основной ветки важно, чтобы ваша ветка фичи не отстала от текущего состояния проекта и чтобы минимизировать возможность конфликтов при слиянии.

`git checkout feature/new-feature`

`git rebase develop`

`git push origin feature/new-feature`

После выполнения этих шагов, вы можете создать Pull Request (PR) на веб-платформе (например, GitHub), чтобы начать процесс ревью ваших изменений другими участниками проекта. Не забудьте описать свои изменения и добавить необходимую информацию для ревьюера, чтобы им было легче понять, что вы сделали и почему.


### Ревью кода и слияние фичи

Другие разработчики рассматривают раннее созданный Pull Request, предлагают изменения и оставляют комментарии. После завершения ревью фича готова к слиянию с основной веткой.

`git checkout develop`

`git pull origin develop`

`git merge --no-ff feature/new-feature`

`git push origin develop`

Если в процессе работы над вашей фичей были изменения в основной ветке, при слиянии Pull Request может возникнуть конфликт. Git попросит вас разрешить этот конфликт, редактируя конфликтные файлы вручную. После разрешения конфликта, сделайте коммит и продолжайте процесс слияния PR.

### Релиз

Для подготовки новый версии проекта создается релизная ветка. Происходит это, когда завершено достаточное количество фич.

`git checkout develop`

`git pull origin develop`

`git checkout release/0.0.1`


### Исправление ошибок в релизе

Если в уже созданном релизе имеются ошибки, разработчики могут исправить их прямо в релизной ветке.

`git commit -m "fix: solved [critical bug]"`

`git push origin release/0.0.1`


### Завершение релиза и создание тега

Когда все ошибки успешно исправлены и релиз готов к выпуску, создается тег. 

`git checkout main`

`git merge --no-ff release/0.0.1`

`git tag -a 0.0.1 -m "Release 0.0.1"`

`git push origin main`

`git push origin --tags`


### Поддержка релиза

Если вдруг после выпуска релиза были обнаружены ошибки, то разработчик может их исправить в той же ветке, закоммитив и внеся изменения.

`git checkout release/0.0.1`

`git commit -a -m "fix: solved [critical post-release bug]"`

`git push origin release/0.0.1`


### Внедрение исправлений в основную ветку

Для того, чтобы внесенные в релизную ветку изменения были доступны в будущем в других релизах, эти изменения могут быть внедрены в основную ветку разработки. Разработчик хочет внести изменения в код ветки фичи, для этого он должен коммитить изменения и пушить их в удаленный репозиторий:

`git checkout develop`

`git pull origin develop`

`git merge --no-ff release/0.0.1`

`git push origin develop`


### Удаление веток

Ненужные ветки, оставшиеся после завершения работы над фичами и релизами могут быть удалены.

`git branch -d feature/new-feature`

`git branch -d release/0.0.1`

`git push origin --delete feature/new-feature`

`git push origin --delete release/0.0.1`

### Удаление файлов

Для удаления файла из индекса и физически из файловой системы можно использовать:

`git rm <file>`

Для удаления файла из индекса, но не физически из файловой системы можно использовать:

`git rm --cached <file>`

### Переход к старому коммиту

Сначала вы должны найти хеш коммита, к которому вы хотите вернуться. Это можно сделать, используя команду `git log`, чтобы просмотреть историю коммитов и скопировать хеш нужного коммита. Далее на базе этого хеша коммита можно создать новую ветку, и делать с ней то, что уже рассматривалось: вносить изменения, объеденять изменения с другими ветками.

`git checkout -b <new_branch> <hash>`

 Если вам нужно вернуться к предыдущему состоянию, вы можете сделать это, переключившись обратно на другую ветку.

 `git checkout -b <branch>`

 ### Отмена предыдущего коммита

 Для отмены предыдущих коммитов, создаются новые коммиты, которые отменяют изменения предыдущих коммитов.

 `git revert <hash>`

### Чтобы закоммитить файл с любой датой 

Вы можете использовать команду `git commit` с параметром `--date`. Это позволит вам установить желаемую дату и время для коммита. Вот как это можно сделать:

Убедитесь, что файл добавлен в индекс:
Сначала убедитесь, что файл добавлен в индекс с помощью команды `git add`.

`git add` имя_файла

Сделайте коммит с указанием даты:
Используйте команду `git commit` с параметром `--date`, чтобы установить дату коммита на 23 мая. Вы также можете указать время, если это необходимо.

`git commit --date="2025-05-23T12:00:00" -m "Ваше сообщение коммита"`

В этом примере 2025-05-23T12:00:00 устанавливает дату на 23 мая 2025 года в 12:00. Вы можете изменить время по своему усмотрению.

Отправьте изменения в удалённый репозиторий (если необходимо):
Если вы хотите отправить этот коммит в удалённый репозиторий, используйте команду `git push`.

`git push origin имя_ветки`

Замените имя_ветки на имя ветки, в которой вы работаете.